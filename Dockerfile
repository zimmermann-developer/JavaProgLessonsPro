# =========================
# STAGE 1: BUILD (сборка jar)
# =========================

# (1) Берём официальный Maven-образ с JDK 21 (Temurin).
#     Он содержит Maven + JDK, чтобы мы могли собрать проект.
FROM maven:3.9.9-eclipse-temurin-21 AS build

# (2) Рабочая директория внутри контейнера на этапе сборки.
WORKDIR /app

# (3) Копируем сначала pom.xml отдельно.
#     Это важная оптимизация: Docker кеширует слои.
#     Если код меняется часто, а pom.xml редко — зависимости будут кешироваться.
COPY pom.xml /app/

# (4) Скачиваем зависимости заранее (без исходников).
#     Это ускоряет повторные сборки.
RUN mvn -q -e -DskipTests dependency:go-offline

# (5) Теперь копируем исходный код.
COPY src /app/src

# (6) Собираем Spring Boot приложение в jar.
#     -DskipTests: на лекции можно пропускать тесты (быстрее).
#     В CI обычно делают отдельный шаг для тестов.
RUN mvn -q -DskipTests package

# =========================
# STAGE 2: RUNTIME (запуск приложения)
# =========================

# (7) Берём лёгкий runtime-образ с JRE 21 (без Maven, без компилятора).
#     Это уменьшает размер итогового образа и повышает безопасность.
FROM eclipse-temurin:21-jre

# (8) Создаём рабочую папку для приложения.
WORKDIR /app

# (9) Копируем jar из предыдущего stage (build) в runtime stage.
#     Имя jar у разных проектов разное, поэтому используем маску.
COPY --from=build /app/target/*.jar /app/app.jar

# (10) Сообщаем, что контейнер внутри будет слушать порт 8080.
#      Это "документация" для образа. Порт реально открывается через -p.
EXPOSE 8080

# (11) Рекомендуемый способ запуска Java в контейнере:
#      - "exec form" (JSON массив) — корректно обрабатывает сигналы Docker (SIGTERM),
#      чтобы Spring Boot нормально завершал работу.
#
#      Дополнительно можно прокинуть профиль через переменную окружения:
#      SPRING_PROFILES_ACTIVE=...
#
#      Можно также добавить JVM options через JAVA_TOOL_OPTIONS (см. ниже).
ENTRYPOINT ["java", "-jar", "/app/app.jar"]